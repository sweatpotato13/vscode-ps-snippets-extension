{
    "Template": {
        "prefix": "ps-template",
        "description": "PS template",
        "body": [
            "#pragma warning(disable : 4996)",
            "#include <bits/stdc++.h>",
            "#define all(x) (x).begin(), (x).end()",
            "using namespace std;",
            "typedef long long ll;",
            "typedef long double ld;",
            "typedef vector<ll> vll;",
            "typedef vector<ld> vld;",
            "typedef pair<ll, ll> pll;",
            "typedef pair<ld, ld> pld;",
            "typedef tuple<ll, ll, ll> tl3;",
            "#define X first",
            "#define Y second",
            "#define FOR(a, b, c) for (int(a) = (b); (a) < (c); ++(a))",
            "#define FORN(a, b, c) for (int(a) = (b); (a) <= (c); ++(a))",
            "#define rep(i, n) FOR(i, 0, n)",
            "#define repn(i, n) FORN(i, 1, n)",
            "#define tc(t) while (t--)",
            "int main() {",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(nullptr);",
            "",
            "    return 0;",
            "}"
        ]
    },
    "KMP": {
        "prefix": "ps-kmp",
        "description": "KMP algorithm is string-searching algorithm, which is used to find a substring in a string. T is the type of the string. Q is the substring. it will return the index of the substring in the string.",
        "body": [
            "template<typename T> struct KMP {",
            "    vector<int> fail;",
            "    vector<int> failure(const T &Q) {",
            "        fail.resize((int)Q.size() + 1);",
            "        for(int i = 1, j = 0; i < (int)Q.size(); ++i) {",
            "            while(j > 0 && Q[i] != Q[j]) j = fail[j - 1];",
            "            if(Q[i] == Q[j]) fail[i] = ++j;",
            "        }",
            "        return fail;",
            "    }",
            "    vector<int> kmp(const T& P, const T& Q) {",
            "        if(fail.size() == 0) failure(Q);",
            "        vector<int> res;",
            "        for(int i = 0, j = 0; i < (int)P.size(); ++i) {",
            "            while(j > 0 && P[i] != Q[j]) j = fail[j - 1];",
            "            if(P[i] == Q[j]) {",
            "                if(j + 1 == (int)Q.size()) res.push_back(i - (int)Q.size() + 1), j = fail[j];",
            "                else ++j;",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "}"
        ]
    },
    "Trie": {
        "prefix": "ps-trie",
        "description": "Trie is a tree-like data structure that stores a dynamic set of strings. It is used to store strings in such a way that searching for a string is efficient. function insert is used to insert a string into the trie. it return true if the prefix of the string already exists in the trie. function find is used to find a string in the trie. it return true if the string exists in the trie. function clear is used to clear the trie.",
        "body": [
            "namespace Trie {",
            "    struct Node {",
            "        char data;",
            "        map<char, Node*> _next;",
            "        Node() { }",
            "        ~Node() { for(auto &i: _next) delete i.second; }",
            "        Node* insert(char x) { if(!find(x)) _next[x] = new Node(); return _next[x]; }",
            "        Node* next(char x) { return _next.count(x) ? _next[x] : nullptr; }",
            "        bool find(char x) { return _next.count(x) != 0; }",
            "        bool end() { return _next.count(0); }",
            "    } *root = new Node();",
            "    int words = 0;",
            "    bool insert(const string &word) {",
            "        bool prefix_exist = false;",
            "        Node *cursor = root;",
            "        for (int i = 0; i < (int)word.size(); i++) {",
            "            cursor = cursor->insert(word[i]);",
            "            if(cursor->end()) prefix_exist = true;",
            "        }",
            "        if(!cursor->end()) {",
            "            cursor->insert(0);",
            "            ++words;",
            "            if(cursor->_next.size() > 1) prefix_exist = true;",
            "        }",
            "        return prefix_exist;",
            "    }",
            "    bool find(const string &str) {",
            "        Node *cursor = root;",
            "        for (int i = 0; i < (int)str.size(); i++) {",
            "            if(!cursor->find(str[i])) return false;",
            "            cursor = cursor->next(str[i]);",
            "        }",
            "        return cursor->end();",
            "    }",
            "    void clear() {",
            "        delete root;",
            "        root = new Node();",
            "        words = 0;",
            "    }",
            "}"
        ]
    }
}
